# [제1장] 함수를 이용한 추상화  
이 장에서 공부할 것은 `계산적 과정`이라는 아이디어.  
계산적 과정(과정)은 컴퓨터 안에 사는 추상적인 존재.  
과정은 점차 전개되며 데이터라고 부르는 또 다른 존재를 조작하게 됨.  
하나의 과정은 일정한 규칙들의 패턴에 따라 전개되는데, 그러한 패턴이 바로 프로그램.  
인간은 프로그램을 작성함으로써 과정의 전개를 이끔.  

프로그램은 난해하고 비밀스러운 프로그래밍 언어로 만들어진 기호 표현식들로 세심하게 구성되며,  
과정이 수행해야 할 과제들을 상세하게 서술함.  
정확하게 작동하는 컴퓨터 안에서 계산적 과정은 프로그램들을 엄밀하고 정확하게 수행함.  
따라서, 마치 마법사의 제자처럼 _초보 프로그래머는 반드시 자신이 불러낸 과정이 어떤 일을 하는지 이해하고 예측하는 방법을 배워야 함._  
프로그램에 사소하더라도 오류(버그)가 있으면 복잡하고 예측하지 못한 결과가 발생할 수 있음.  
숙련된 소프트웨어 기술자들은 자신이 불러낸 계산적 과정이 주어진 과제를 의도 대로 잘 수행할 것임을 스스로 상당히 확신할 수 있도록 **프로그램을 조직화하는 능력**을 갖추고 있음.  
그런 소프트웨어 기술자들은 시스템의 행동을 미리 머릿속에 그릴 수 있고, 예기치 못한 문제가 발생해도 재앙적인 결과로 이어지지 않도록 프로그램의 구조를 짜는 방법을 알고 있음.  
실제로 문제가 발생한 경우 `디버깅`하는 능력도 갖추고 있음.  
잘 설계된 자동차나 원자로처럼 **잘 설계된 계산적 시스템은 모듈식으로, 개별 부품을 따로 작성, 교체, 디버깅 할 수 있는 형태로 만들어짐.**

<br/>

## 1.1 프로그래밍의 기본 요소 
강력한 프로그래밍 언어는 단지 컴퓨터가 수행할 과제를 지시하는 수단 이상의 어떤 것.  
프로그래밍 언어는 우리가 **과정**에 관한 **생각**들을 **조직화**하는 틀로도 작용.  
*→ 프로그래밍 언어를 고찰할 때는 단순한 아이디어들을 조합해서 좀 더 복잡한 아이디어를 만드는 데 사용하는 수단에 주의를 기울여야 함.*  

<br/>

모든 강력한 언어는 이를 위해 세 가지 매커니즘을 제공  
**1.원시 표현식(primitive expression):** 언어와 관련한 가장 `단순한 개체`.  
**2.조합 수단(combination):** 단순한 요소들로부터 `복합적인 요소`를 만드는데 쓰임.  
**3.추상화 수단(abstraction):** 복합적인 요소들에 이름을 붙여서 `하나의 단위`로 다루는데 쓰임.  

프로그래밍에서 우리가 다루는 요소들은 크게 `함수`와 `데이터`로 구분.  
(사실 이 둘은 명백하게 구분되지 않음)
- 데이터 - 우리가 조작하고자 하는 '재료'
- 함수 - 데이터를 다루는 규칙들을 서술한 것.

따라서 모든 강력한 프로그래밍 언어는 반드시 **원시 데이터와 원시 함수를 서술하는 기능**이 있어야 하며,  
**함수와 데이터를 조합하고 추상화하는 수단**도 제공해야 함.

### 1.1.1 표현식

Q.사람과 JavaScript 해석기(인터프리터) 사이의 상호작용 방식이란?  
A.사람이 해석기의 프롬포트에서 하나의 `문장`을 입력하고, 해석기가 그 문장을 `평가`해 결과를 화면에 표시하는 것.  

해석기에 입력해볼 만한 문장으로 `표현식`이 있음.  
표현식 문장은 표현식과 세미 콜론으로 구성.    
표현식은 하나 이상의 원시 표현식으로 구성되는데, 여러 원시 표현식 중 하나로 수(number)가 있음.   

ex) JavaScript 인터프리터에 다음과 같은 프로그램을 입력하면, 486이라는 평가 결과를 출력. 
```JavaScript
486;   //486 출력
```

수를 나타내는 표현식들을 연산자(+, * 등)로 조합 가능.  
그 결과는 연산자에 해당하는 원시 함수를 해당 수들에 적용하는 하나의 복합 표현식.  
ex) 복합 표현식 예시   
```JavaScript
137 + 349;  // 486
5 * 99;     // 495
```
이처럼 다른 표현식을 구성요소로 갖는 표현식을 조합이라고 한다.  
위의 예처럼 가운데에 연산자가 있고 그 왼쪽과 오른쪽에 피연산자 표현식들이 있는 형태의 조합을 연산자 조합이라고 한다.    
연산자 조합의 값은 연산자로 지정된 함수를 인수들, 즉 피연산자 값들에 적용한 결과.    

중위 표기법: 연산자를 두 피연산자 사이에 배치하는 관례.   
수학에서 수식 안에 수식을 중첩하는 것처럼 연산자 조합도 중첩 가능.   
즉, 연산자 조합 자체를 다른 연산자 조합의 피연산자로 사용 가능.   
```JavaScript
(3*5) + (10-6);
```
수학에서처럼 자바스크립트에서도, 연산 순서의 혼동을 피하기 위해 소괄호로 연산자 조합들을 묶을 수 있음.   
소괄호를 생략하면 자바스크립트는 통상 관례에 따라 연산 순서를 결정. 
즉, 곱셈과 나눗셈을 덧셈과 뺄셈보다 먼저 처리.  
이러한 관례를 일컬어 연산자 `*`와 `/`가 연산자 `+`, `-`보다 우선순위가 높다고 함.  
일련의 덧셈과 뺄셈, 곱셈, 나눗셈은 왼쪽에서 오른쪽으로 평가되며, 이런 관례를 일컬어 연산자 `+`, `-`, `*`, `/`가 `왼쪽 결합`이라고 말함.  
자바스크립트 인터프리터가 평가할 수 있는 표현식의 전반적인 복잡도에는 이론적으로 제한이 없음.  
반면 사람은 비교적 간단한 표현식도 헷갈림. 
자바스크립트 해석기는 복잡한 표현식 문장이 주어져도 항상 동일한 기본 주기(cycle)로 작동.  
해석기는 사용자가 입력한 문장을 읽고(read), 그 문장을 평가(evaluate)하고, 결과를 출력(print)함.   
이러한 
해석기는 사용자가 입력한 문장을 읽고(read), 그 문장을 평가(evaluate)하고, 결과를 출력(print)함.   

이러한 주기를 반복하는 것을 가리켜 REPL(Read-Evalutae-Print Loop)라고 함.   
자바스크립트는 REPL에서 출력을 위해 특별한 명령이 필요하지 않다.  
해석기는 특별한 명령없이도 주어진 표현식의 평가 결과를 출력한다.  


--------------


### 1.1.2 이름 붙이기와 환경  
계산적 객체(computational object)에 이름을 붙여서 이름으로 그 객체를 지칭하는 수단들은 프로그래밍 언어의 필수 기능에 해당.  
> 상수의 이름: 해당 객체의 값을 지칭하는 용도.  

자바스크립트에서 상수에 이름을 붙이는 수단은 다음과 같이 `const`라는 키워드로 시작하는 상수 선언.   
```JavaScript
const size = 2;
```
- 이 문장에 대해 해석기는 2라는 값을 `size`라는 이름에 연관시킴.  
- 일단 `size라는` 이름에 2라는 수가 연관되면, 그때부터는 값 2를 `size라는` 이름으로 지칭 가능.   

<br/>

**복합적인 연산의 결과를 간단한 이름으로 지칭**할 수 있다는 점에서, `상수 선언`은 우리의 언어에서 **가장 단순한 추상화 수단**이다.   
일반적으로 객체는 구조가 대단히 복잡할 수 있기 때문에, 복잡한 구조의 세부사항을 기억해 두고 객체를 사용할 때 마다 그 구조를 거듭 명시하는 것은 극히 불편한 일.    
실제로, 복잡한 프로그램은 점차 더 복잡한 계산적 객체들을 구축해 나가는 식으로 만들어 진다.   
해석기를 이용하면 이름-객체 연관 관계를 일련의 상호작용을 통해서 점진적으로 만들어 나갈 수 있으므로 프로그램을 단계적으로 구축하기가 특히 편리.  
이름과 값을 연관시키고 이름으로부터 값을 조회할 수 있으려면, 해석기는 반드시 이름-객체 쌍들을 저장하고 관리하는 특정한 메모리 공간을 갖추어야 함.   
그러한 메모리 공간을 `환경(environment)`이라고 함. (좀 더 정확하게는 프로그램 환경)

--------------    

### 1.1.3 연산자 조합의 평가   
이번 장의 목표 중 하나는 `절차적 사고`에 관한 논점들을 잘 구분하는 것.   
ex) 연산자 조합을 평가할 때 해석기가 따르는 절차    
1. 조합의 피연산자 표현식들을 평가.    
2. 연산자가 나타내는 함수를 인수(피연산자들의 값)들에 적용.    

단순하지만 이 규칙은 계산적인 과정에 관해 일반적으로 중요한 사항들을 잘 보여줌.   
첫 번째, 단계 1은 주어진 조합의 평가 과정을 완료하기 위해서는 먼저 조합의 각 피연산자를 평가해야 함을 말함.   
→ 이는 규칙의 한 단계에서 규칙 자신을 수행해야 함을 뜻함.
→ 즉, 이 평가 규칙은 `재귀적`이다.    
→ 재귀라는 개념 덕분에 깊게 중접된 조합의 평가 규칙도 아주 간결하게 표현할 수 있음.    

두 번째, 단계 1을 재귀적으로 거듭 적용하다 보면 조합이 아니라 원시 표현식(수치, 이름 등)을 평가해야 하는 지점에 도달한다는 점도 중요.   
원시 표현식 평가에는 다음과 같은 규칙들이 적용됨.    
- 수치의 값은 해당 숫자들이 나타내는 그 값.   
- 이름의 값은 현재 환경에서 그 이름에 연관된 객체.   

여기서 주목할 점은 표현식 안의 이름이 결정하는 바를 환경이 결정한다는 점.    
자바스크립트 같은 대화식(상호작용식) 언어에서 `x+1` 같은 표현식의 값을 이야기하려면 x라는 **이름의 의미를 제공하는 환경에 관한 정보가 꼭 필요.**   
**평가가 일어나는 문맥을 제공하는 환경이라는 일반적인 개념은 우리가 프로그램의 실행을 이해할 때 중요한 역할을 함.**   

앞으 평가 규칙이 선언에는 적용되지 않음을 주의!   
```JavaScript
const x = 3;
```  
위 문장을 평가할 때, 해석기가 두 인수(x라는 이름이 지칭하는 값과 3)에 상등 연산자 `=`를 적용하지는 않음.    
선언은 이름을 값에 연관시키는 것만을 목적으로하는 특별한 종류의 프로그램 구성요소.   
(즉, const x = 3;은 조합이 아니다.)   

문장 안에서 하나의 키워드 또는 키워드들의 조합을 만나면 자바스크립트 해석기는 그 문장을 특별한 방식으로 처리.   
키워드를 포함한 문장을 `구문형`이라고 부르는데, 각각의 구문형마다 고유한 평가 규칙이 있음.   
다양한 종류의 문장들과 표현식들은 프로그래밍 언어의 `구문론(Syntax)`을 형성.     

